/*
* Tuple Relational Query Specification
*/

options
{
  static = true;
}

PARSER_BEGIN(TrcGrammar)
package trcGrammar;
import trcQueryElements.*;

public class TrcGrammar
{
  public static void main(String args []) throws ParseException
  {
    TrcGrammar parser = new TrcGrammar(System.in);
 	Query p = parser.query();   
  }
}

PARSER_END(TrcGrammar)



//TODO: Definir comentarios no skip
TOKEN:
{
    < #BREAKLINE  : "\n"|"\r\n" >
}

SKIP :
{
  " "
| "\r"
| "\r\n"
| "\t"
| "\n"
}

SPECIAL_TOKEN :
{
  <COMENTARIO_UMA_LINHA: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN: /*ABREVIACOES*/
{
  < #LETRA : ["a"-"z"]|["A"-"Z"] >
| < #DIGITO : ["0"-"9"] >
}

/* OPERADORES LOGICOS */
TOKEN :
{
  <OR : "OR">
  | <AND : "AND">
  | <NOT : "NOT">
}

/*QUANTIFICADORES*/
TOKEN :
{
  <EXISTS : "EXISTS">
  | <FORALL : "FORALL">
}


/*COMPARADORES*/
TOKEN :
{
  <LPAREN : "(">
  | <RPAREN : ")">
  | <LBRACE : "{">
  | <RBRACE : "}">
  | <LESSTHAN : "<">
  | <LESSOREQUALTHAN : "<=">
  | <GREATERTHAN : ">">
  | <GREATEROREQUALTHAN : ">=">
  | <EQUALS : "==">
  | <NOTEQUALS : "<>" | "!="> 

}

TOKEN : /*CONSTANTES*/
{
  < INTEIRO_LITERAL : (< DIGITO >)+ >
  | < STRING_LITERAL : "'"(<LETRA>)*"'">
  | < TRUEVALUE : "TRUE" >
  | < FALSEVALUE : "FALSE" >
}

TOKEN : /*IDENTIFICADOR*/
{
  < IDENTIFICADOR : ( < LETRA > )(< LETRA > | "_" | < DIGITO >)*  >
  | <DOT : ".">
}

TOKEN :
{
	<MEIODAQUERY  :"|">
}



//Usar o padrao factory pra gerar Formulas com operator

AtomicFormula atomicFormula():
{
	AtomicFormula af;
	Token token1;
	Token token2;
	Token token3;
	Token token4;
	Token operator;
}
{	
	(
		token1 = <IDENTIFICADOR> 
		(	
			<LPAREN> token2 = <IDENTIFICADOR> <RPAREN> 
			{af = new AtomicFormulaIsA(tableName.image, tupleName.image);}
			
			| <DOT> token2 = <IDENTIFICADOR> 
				(	
					operator = <LESSTHAN> 
					| operator = <GREATERTHAN> 
					| operator = <EQUALS>
					| operator = <LESSOREQUALTHAN>
					| operator = <GREATEROREQUALTHAN>
					| operator = <NOTEQUALS>
				)

			   	( 
			   		token3 = <IDENTIFICADOR> <DOT> token4 = <IDENTIFICADOR>
			   	 	| token3 = <INTEIRO_LITERAL>
			   	 	| token3 = <STRING_LITERAL> 	
			   	)
		)	
	)
	
	| (token1 = <INTEIRO_LITERAL> | token1 = <STRING_LITERAL>)
		(	
					operator = <LESSTHAN> 
					| operator = <GREATERTHAN> 
					| operator = <EQUALS>
					| operator = <LESSOREQUALTHAN>
					| operator = <GREATEROREQUALTHAN>
					| operator = <NOTEQUALS>
		)
		token2 = <IDENTIFICADOR> <DOT> token3 = <IDENTIFICADOR>
		
	{return af;}
}

	


Query query():
{
	Query q = new Query();
	AtomicFormula af;
}
{
	<LBRACE>
	 <IDENTIFICADOR> <MEIODAQUERY> af = atomicFormula()
	<RBRACE>
	{return q;}
}